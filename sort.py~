data = []

with open('text.txt') as text:
        for line in text:
                data.append(line.replace("\n", ""))
        
def sortlist(unsorted):
        for i in range(len(unsorted) - 1):
                for j in range(i + 1, len(unsorted)):
                       if unsorted[i] > unsorted[j]:
                               temp = unsorted[i]
                               unsorted[i] = unsorted[j]
                               unsorted[j] = temp



def selection_sort(nums):
        # This value of i corresponds to how many values were sorted
        for i in range(len(nums)):
                # We assume that the first item of the unsorted segment is the smallest
                lowest_value_index = i
                # This loop iterates over the unsorted items
                for j in range(i + 1, len(nums)):
                        if nums[j] < nums[lowest_value_index]:
                                lowest_value_index = j
                # Swap values of the lowest unsorted element with the first unsorted
                # element
                nums[i], nums[lowest_value_index] = nums[lowest_value_index], nums[i]

def insertion_sort(nums):
        # Start on the second element as we assume the first element is sorted
        for i in range(1, len(nums)):
                item_to_insert = nums[i]
                # And keep a reference of the index of the previous element
                j = i - 1
                # Move all items of the sorted segment forward if they are larger than
                # the item to insert
                while j >= 0 and nums[j] > item_to_insert:
                        nums[j + 1] = nums[j]
                        j -= 1
                # Insert the item
                nums[j + 1] = item_to_insert

def heapify(nums, heap_size, root_index):
        # Assume the index of the largest element is the root index
        largest = root_index
        left_child = (2 * root_index) + 1
        right_child = (2 * root_index) + 2
        
        # If the left child of the root is a valid index, and the element is greater
        # than the current largest element, then update the largest element
        if left_child < heap_size and nums[left_child] > nums[largest]:
                largest = left_child
                
        # Do the same for the right child of the root
        if right_child < heap_size and nums[right_child] > nums[largest]:
                largest = right_child
                
        # If the largest element is no longer the root element, swap them
        if largest != root_index:
                nums[root_index], nums[largest] = nums[largest], nums[root_index]
                # Heapify the new root element to ensure it's the largest
                heapify(nums, heap_size, largest)
                                
def heap_sort(nums):
        n = len(nums)
        
        # Create a Max Heap from the list
        # The 2nd argument of range means we stop at the element before -1 i.e.
        # the first element of the list.
        # The 3rd argument of range means we iterate backwards, reducing the count
        # of i by 1
        for i in range(n, -1, -1):
                heapify(nums, n, i)
                
        # Move the root of the max heap to the end of
        for i in range(n - 1, 0, -1):
                nums[i], nums[0] = nums[0], nums[i]
                heapify(nums, i, 0)
                
#insertionSortFruits(data)
#print(f"Unsorted Data: {data}")
heap_sort(data)
print(f"Sorted Data: {data}")
